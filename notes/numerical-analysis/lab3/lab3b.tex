\documentclass[11pt]{article}

\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}

% Define colors for syntax highlighting
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

% Set up the MATLAB code listing style
\lstset{
  backgroundcolor=\color{white},
  basicstyle=\footnotesize\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{mygreen},
  deletekeywords={...},
  escapeinside={\%*}{*)},
  extendedchars=true,
  frame=single,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=Matlab,
  otherkeywords={*,...},
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{mygray},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=1,
  stringstyle=\color{mymauve},
  tabsize=2,
  title=\lstname
}


% Adjust the margins if needed
\usepackage[left=1in, right=1in, top=1in, bottom=1in]{geometry}
\usepackage{graphicx}
\usepackage{graphicx}
\usepackage{tabto}

% Set the title and author
\title{Solving Systems of Equations, Errors and Explorations}
\author{David Tran and Spencer Kelly}
\date{\today}

\begin{document}

\maketitle

\subsection*{Abstract}

\section{Introduction}

\section{The PA = LU factorization method for linear systems}

\subsection{Why is PA = LU needed for solving linear systems approximately?}

When solving linear systems of the form $Ax = b$, we begin by gaussian elimination of the matrix $A$, followed by back substitution, and ultimately arrive at our solution.
However, when a particular matrix $A$ is being used for multiple iterations, the overhead involved can become quite an obstacle.
This is because the process of Gaussian elimination is a computationally expensive process, with complexity on the order $O(n^3)$.
But with $PA = LU$ factorization, we essentially remove the overhead involved with Gaussian elimination, for all but the first iteration, by rewriting the matrix $A$ in terms of the upper and lower matrices $L$, and $U$, respectively.
Thus, for every subsequent iteration involving the same matrix, we need not perform gaussian elimination, since $L$ and $U$ allow us to immediately begin performing the second step of solving;
back-substitution, which only has complexity $O(n^2)$.

However, when performing naive Gaussian elimination to form the matrices $L$ and $U$, we are at risk of swamping, or the existence of a zero-pivot.
With the help of a permutation matrix $P$, we can now swap rows and columns, to mitigate the propogation of errors due to multiplying rows by large values, and avoid zero-pivots.
The permutation matrix $P$ keeps track of the swapping of rows and columns, so that the linear system itself remains unperturbed (however it is now written $PAx = Pb$).

A great example would be the system $Ax = b$  with $A = \begin{pmatrix}1 & 2 & 4\\3 & 8 & 14\\ 2 & 6 & 13\\
\end{pmatrix}$.
To begin, we swap rows 1 and 2, since we want our multiplication to be by the smallest values possible during Gaussian elimination.
When doing this, we update our permutation matrix: $P = \begin{pmatrix}0&1&0\\1&0&0\\0&0&1
\end{pmatrix}$, and we can subsequently perform gaussian elimination to yield the matrix $\begin{pmatrix}3&8&14\\(\frac{1}{3})&\frac{-2}{3}&\frac{-2}{3}\\(\frac{2}{3})&\frac{2}{3}&\frac{11}{3}
\end{pmatrix}$, where the brackets around the values in the place of what should be $0$ represents the multiplier for the elimination of the row, (important for bookkeeping when doing permutations).

Once again performing Gaussian elimination we obtain the matrix $\begin{pmatrix}3&8&14\\(\frac{1}{3})&\frac{-2}{3}&\frac{-2}{3}\\(\frac{2}{3})&(-1)&3
\end{pmatrix}$.
From this matrix, we can easily find that $L = \begin{pmatrix}1&0&0\\\frac{1}{3}&1&0\\\frac{2}{3}&-1&1
\end{pmatrix}$ and $U = \begin{pmatrix}3&8&14\\0&\frac{-2}{3}&\frac{-2}{3}\\0&0&3
\end{pmatrix}$.
We can then use these to solve linear systems for $b_k$, with the increased efficiency of $LU$ factorization, and the error mitigation of the pivots enabled by the inclusion of the permutation matrix.\\


\subsection{How to identify systems Ax = b for which PA = LU is not suited}
Although it is a very effective direct method of giving (theoretically) the exact solution of the linear system, PA = LU factorization is not always the tool you want to employ for solving said linear system.
For example, if the matrix involved is positive definite, and symmetric, we can employ methods such as Cholensky Factorization, which is more efficient.
If the matrix is not only positive definite and symmetric, but also sparse, we can employ the Conjugate Gradient Method, which is even more efficient than the aforementioned method, and has even lower memory demand.

\subsection{Larger applications of PA = LU factorization}
The applications of $PA = LU$ factorization extend beyong just solving linear systems,and can be used to solve very common problems.
One such problem is solving for the inverse of a matrix, which is made significantly easier when said matrix is decomposed into upper and lower matrices via $PA = LU$ factorization.
On top of this, we can easily compute the determinant of a matrix given its $PA = LU$ factorization, when we recall that the determinant of a triangular matrix is just its diagonal entries, and that the determinant of a permutation matrix is just $(-1)^n$, where $n$ is the number of rows swapped by the permutation.

\section{Iterative solution of systems of linear equations}

\subsection{Solving an equation for n = 100,000}

\subsection{Comparison of PA = LU and Jacobi Iteration}

\subsection{Why is solving such large systems important in applications?}

\section{Implement Newton's method for multiple variables}

\subsection{Implement Newton's method for systems using vectorization}

\subsection{Testing}

\subsection{Challenging Example}

\section{Summary}

\section{Appendices}

\subsection{Code}

\subsection{Plots}





\section{Code}



\section{Summary}
\subsection{Results}


\subsection{Team Description}


\subsection{Future Explorations}


\subsection{References}

\section*{Appendix}


\end{document}
